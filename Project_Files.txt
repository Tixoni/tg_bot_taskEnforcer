[Файл: c:\Users\Tixon11\obsidian\NewObsidian\Интеллект\Технический\Programming\aiogram\tg_bot_TaskEnforcer\requirements.txt]
[Размер: 111 байт]
[Дата изменения: 2026-01-31 19:51:52.989718]

aiogram==3.17.0
fastapi==0.115.0
uvicorn==0.34.0
pydantic==2.10.0
requests==2.32.3
psycopg[binary]==3.1.18
-----

[Файл: c:\Users\Tixon11\obsidian\NewObsidian\Интеллект\Технический\Programming\aiogram\tg_bot_TaskEnforcer\runtime.txt]
[Размер: 11 байт]
[Дата изменения: 2026-01-31 17:33:15.106470]

python-3.12
-----

[Файл: c:\Users\Tixon11\obsidian\NewObsidian\Интеллект\Технический\Programming\aiogram\tg_bot_TaskEnforcer\web\script.js]
[Размер: 3121 байт]
[Дата изменения: 2026-01-31 18:31:26.429208]

const API_BASE_URL = "https://tgbottaskenforcer-production.up.railway.app";

const tg = window.Telegram.WebApp;
tg.ready();
tg.expand();

const tgUser = tg.initDataUnsafe.user;

if (!tgUser?.id) {
    tg.showAlert("Не удалось получить данные Telegram");
    throw new Error("No Telegram user");
}

const userId = tgUser.id;
const userName =
    tgUser.username ||
    tgUser.first_name ||
    "TelegramUser";

// === АВТО-РЕГИСТРАЦИЯ ===
(async function init() {
    try {
        await fetch(`${API_BASE_URL}/api/register`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                tg_id: userId,
                name: userName
            })
        });

        showTasksScreen();

    } catch (e) {
        console.error(e);
        tg.showAlert("Не удалось подключиться к серверу");
    }
})();

// ================= TASKS =================
async function loadTasks() {
    const list = document.getElementById("tasks-list");

    try {
        const res = await fetch(`${API_BASE_URL}/api/tasks/${userId}`);
        if (!res.ok) throw new Error("Load failed");

        const tasks = await res.json();
        list.innerHTML = "";

        tasks.forEach(task => {
            const div = document.createElement("div");
            div.className =
                "card p-4 rounded-xl flex items-center justify-between shadow-sm";

            div.innerHTML = `
                <span class="${task.is_completed ? "task-completed" : ""}">
                    ${task.title}
                </span>
                <input type="checkbox"
                    ${task.is_completed ? "checked" : ""}
                    onclick="toggleTask(${task.id})">
            `;

            list.appendChild(div);
        });

    } catch (e) {
        console.error(e);
        tg.showAlert("Ошибка загрузки задач");
    }
}

async function addNewTask() {
    const input = document.getElementById("task-input");
    const title = input.value.trim();
    if (!title) return;

    try {
        await fetch(`${API_BASE_URL}/api/tasks/add`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ user_id: userId, title })
        });

        input.value = "";
        loadTasks();

    } catch (e) {
        console.error(e);
        tg.showAlert("Ошибка добавления задачи");
    }
}

async function toggleTask(taskId) {
    try {
        await fetch(`${API_BASE_URL}/api/tasks/toggle/${taskId}`, {
            method: "POST"
        });

        tg.HapticFeedback?.impactOccurred("light");
        loadTasks();

    } catch (e) {
        console.error(e);
        tg.showAlert("Ошибка изменения задачи");
    }
}

function showTasksScreen() {
    document.getElementById("tasks-screen").classList.remove("hidden");
    loadTasks();
}

-----

[Файл: c:\Users\Tixon11\obsidian\NewObsidian\Интеллект\Технический\Programming\aiogram\tg_bot_TaskEnforcer\web\index.html]
[Размер: 1094 байт]
[Дата изменения: 2026-01-31 18:32:03.605098]

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Enforcer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body class="p-4">

    <div id="tasks-screen" class="max-w-md mx-auto hidden">
        <h1 class="text-xl font-bold mb-4">
            Твои задачи
        </h1>

        <div class="flex gap-2 mb-6">
            <input type="text" id="task-input"
                placeholder="Что нужно сделать?"
                class="flex-1 px-4 py-2 border rounded-lg text-black outline-none">
            <button onclick="addNewTask()"
                class="bg-green-600 text-white px-4 py-2 rounded-lg font-bold">
                +
            </button>
        </div>

        <div id="tasks-list" class="space-y-3"></div>
    </div>

    <script src="script.js"></script>
</body>

</html>
-----

[Файл: c:\Users\Tixon11\obsidian\NewObsidian\Интеллект\Технический\Programming\aiogram\tg_bot_TaskEnforcer\web\style.css]
[Размер: 519 байт]
[Дата изменения: 2026-01-29 14:48:13.284878]

/* Использование цветов темы Telegram для нативности */
body {
    background-color: var(--tg-theme-bg-color, #f5f5f5);
    color: var(--tg-theme-text-color, #222);
}

.card {
    background-color: var(--tg-theme-secondary-bg-color, #ffffff);
}

.task-completed {
    text-decoration: line-through;
    opacity: 0.5;
}

/* Кастомный чекбокс для красоты */
input[type="checkbox"] {
    accent-color: var(--tg-theme-button-color, #2481cc);
}
-----

[Файл: c:\Users\Tixon11\obsidian\NewObsidian\Интеллект\Технический\Programming\aiogram\tg_bot_TaskEnforcer\config.py]
[Размер: 47 байт]
[Дата изменения: 2026-01-31 17:18:53.209299]

import os

TOKEN = os.getenv("BOT_TOKEN", "")
-----

[Файл: c:\Users\Tixon11\obsidian\NewObsidian\Интеллект\Технический\Programming\aiogram\tg_bot_TaskEnforcer\Copy_Files_POSSIBLE_DANGER_RUN_ONLY_HERE.py]
[Размер: 5446 байт]
[Дата изменения: 2026-01-31 17:28:36.274893]

import os
import sys
import glob
from pathlib import Path
from datetime import datetime

def main():
    # Установка корневой директории
    if len(sys.argv) > 1:
        root_dir = sys.argv[1]
    else:
        root_dir = os.path.dirname(os.path.abspath(__file__))
    
    # Проверка существования директории
    if not os.path.exists(root_dir):
        print(f'Ошибка: Директория "{root_dir}" не существует!')
        input('Нажмите Enter для выхода...')
        return 1
    
    # Получение абсолютного пути
    root_dir = os.path.abspath(root_dir)
    
    print(f'Рабочая директория: {root_dir}')
    print()
    
    # Удалить существующий файл результатов
    if os.path.exists('Project_Files.txt'):
        os.remove('Project_Files.txt')
    
    # Список разрешенных расширений для исходного кода
    allowed_extensions = [
        '*.txt', '*.bat', '*.cmd', '*.ps1', '*.js', '*.html', '*.css', 
        '*.py', '*.java', '*.c', '*.cpp', '*.h', '*.cs', '*.php', 
        '*.xml', '*.json', '*.config', '*.ini', '*.md', '*.sql', 
        '*.yml', '*.yaml'
    ]
    
    # Исключаемые директории
    exclude_dirs = ['.git', 'node_modules', 'bin', 'obj', 'packages', '.vs', '.idea']
    
    # Максимальный размер файла (1 МБ)
    max_size = 1048576
    
    print('Начало обработки файлов...')
    print()
    
    processed_files = 0
    skipped_files = 0
    
    # Рекурсивный поиск файлов
    for extension in allowed_extensions:
        pattern = os.path.join(root_dir, '**', extension)
        
        for file_path in glob.glob(pattern, recursive=True):
            # Проверка на исключаемые директории
            skip_file = False
            for exclude_dir in exclude_dirs:
                if exclude_dir in file_path.split(os.sep):
                    skip_file = True
                    break
            
            if skip_file:
                continue
            
            # Получение информации о файле
            try:
                file_size = os.path.getsize(file_path)
                mod_time = datetime.fromtimestamp(os.path.getmtime(file_path))
                
                # Проверка размера файла
                if file_size < max_size:
                    print(f'Обработка: {file_path}')
                    
                    with open('Project_Files.txt', 'a', encoding='utf-8') as result_file:
                        result_file.write(f'[Файл: {file_path}]\n')
                        result_file.write(f'[Размер: {file_size} байт]\n')
                        result_file.write(f'[Дата изменения: {mod_time}]\n')
                        result_file.write('\n')
                        
                        # Попытка чтения файла
                        try:
                            with open(file_path, 'r', encoding='utf-8') as src_file:
                                content = src_file.read()
                                result_file.write(content)
                        except UnicodeDecodeError:
                            # Попробуем другие кодировки
                            try:
                                with open(file_path, 'r', encoding='cp1251') as src_file:
                                    content = src_file.read()
                                    result_file.write(content)
                            except:
                                result_file.write('[Ошибка чтения файла - возможно бинарный файл]\n')
                        except Exception as e:
                            result_file.write(f'[Ошибка чтения файла: {str(e)}]\n')
                        
                        result_file.write('\n')
                        result_file.write('-----\n')
                        result_file.write('\n')
                    
                    processed_files += 1
                else:
                    print(f'Пропуск большого файла: {file_path} ({file_size} байт)')
                    
                    with open('Project_Files.txt', 'a', encoding='utf-8') as result_file:
                        result_file.write(f'[Файл: {file_path} - ПРОПУЩЕН (слишком большой: {file_size} байт)]\n')
                    
                    skipped_files += 1
                    
            except Exception as e:
                print(f'Ошибка при обработке файла {file_path}: {e}')
    
    print()
    print(f'Готово! Результат сохранен в Project_Files.txt')
    print(f'Обработано файлов: {processed_files}, пропущено: {skipped_files}')
    print(f'Обработана директория: {root_dir}')
    
    # Пауза в конце
    input('Нажмите Enter для выхода...')
    return 0

if __name__ == '__main__':
    sys.exit(main())
-----

[Файл: c:\Users\Tixon11\obsidian\NewObsidian\Интеллект\Технический\Programming\aiogram\tg_bot_TaskEnforcer\run.py]
[Размер: 1190 байт]
[Дата изменения: 2026-01-31 17:26:37.187359]

import asyncio
import logging
import os  # ЭТОГО ИМПОРТА НЕ ХВАТАЛО!
import uvicorn
from aiogram import Bot, Dispatcher
from config import TOKEN
from app.handlers import router
from app.database import init_db
from app.myapi import app  

async def start_bot(bot, dp):
    dp.include_router(router)
    await dp.start_polling(bot)

async def main():
    init_db()
    
    # Инициализируем бота внутри асинхронной функции
    bot = Bot(token=TOKEN)
    dp = Dispatcher()
    
    # Получаем порт от Railway (автоматически)
    port = int(os.environ.get("PORT", 8000))
    
    bot_task = asyncio.create_task(start_bot(bot, dp))
    
    # Используем переменную port
    config = uvicorn.Config(app, host="0.0.0.0", port=port, log_level="info")
    server = uvicorn.Server(config)
    
    logging.info(f"Server starting on port {port}")
    await server.serve()
    await bot_task

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("Exit")
-----

[Файл: c:\Users\Tixon11\obsidian\NewObsidian\Интеллект\Технический\Programming\aiogram\tg_bot_TaskEnforcer\app\database.py]
[Размер: 4612 байт]
[Дата изменения: 2026-01-31 20:13:38.748143]

import os
import psycopg
from psycopg.rows import dict_row

DATABASE_URL = os.getenv("DATABASE_URL")

if not DATABASE_URL:
    raise RuntimeError("DATABASE_URL is not set")


def get_connection():
    return psycopg.connect(
        DATABASE_URL,
        row_factory=dict_row
    )


def init_db():
    with get_connection() as conn:
        with conn.cursor() as cur:

            # USERS
            cur.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    id SERIAL PRIMARY KEY,
                    tg_id BIGINT UNIQUE NOT NULL,
                    username TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
            """)

            # TASKS
            cur.execute("""
                CREATE TABLE IF NOT EXISTS tasks (
                    id SERIAL PRIMARY KEY,
                    user_id BIGINT NOT NULL,
                    title TEXT NOT NULL,
                    is_completed BOOLEAN DEFAULT FALSE,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (tg_id)
                        ON DELETE CASCADE
                );
            """)

            # HABITS
            cur.execute("""
                CREATE TABLE IF NOT EXISTS habits (
                    id SERIAL PRIMARY KEY,
                    user_id BIGINT NOT NULL,
                    title TEXT NOT NULL,
                    completed_date DATE,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (tg_id)
                        ON DELETE CASCADE
                );
            """)

            # Индексы (очень желательно)
            cur.execute("""
                CREATE INDEX IF NOT EXISTS idx_tasks_user_id
                ON tasks(user_id);
            """)

            cur.execute("""
                CREATE INDEX IF NOT EXISTS idx_habits_user_id
                ON habits(user_id);
            """)


# ================= USERS =================

def add_user(tg_id: int, username: str):
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                INSERT INTO users (tg_id, username)
                VALUES (%s, %s)
                ON CONFLICT (tg_id) DO NOTHING;
            """, (tg_id, username))


# ================= TASKS =================

def add_task(user_id: int, title: str):
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                INSERT INTO tasks (user_id, title)
                VALUES (%s, %s);
            """, (user_id, title))


def get_user_tasks(user_id: int):
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                SELECT id, title, is_completed
                FROM tasks
                WHERE user_id = %s
                ORDER BY id DESC;
            """, (user_id,))
            return cur.fetchall()


def toggle_task_status(task_id: int):
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                UPDATE tasks
                SET is_completed = NOT is_completed
                WHERE id = %s;
            """, (task_id,))


# ================= HABITS =================

def add_habit(user_id: int, title: str):
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                INSERT INTO habits (user_id, title)
                VALUES (%s, %s);
            """, (user_id, title))


def get_user_habits(user_id: int):
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                SELECT
                    id,
                    title,
                    completed_date = CURRENT_DATE AS is_completed_today
                FROM habits
                WHERE user_id = %s
                ORDER BY id DESC;
            """, (user_id,))
            return cur.fetchall()


def toggle_habit_today(habit_id: int):
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                UPDATE habits
                SET completed_date = CASE
                    WHEN completed_date = CURRENT_DATE THEN NULL
                    ELSE CURRENT_DATE
                END
                WHERE id = %s;
            """, (habit_id,))

-----

[Файл: c:\Users\Tixon11\obsidian\NewObsidian\Интеллект\Технический\Programming\aiogram\tg_bot_TaskEnforcer\app\handlers.py]
[Размер: 703 байт]
[Дата изменения: 2026-01-28 10:10:24.717264]

from aiogram import F, Router
from aiogram.filters import CommandStart, Command
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext


router = Router()

@router.message(Command("start"))
async def cmd_start(message: Message):
    kb = [
        [KeyboardButton(text="/list")],
        [KeyboardButton(text="/add")]
    ]
    keyboard = ReplyKeyboardMarkup(keyboard=kb,resize_keyboard=True)
    await message.answer("Я заставлю тебя работать маленькая сучка!", reply_markup=keyboard)
-----

[Файл: c:\Users\Tixon11\obsidian\NewObsidian\Интеллект\Технический\Programming\aiogram\tg_bot_TaskEnforcer\app\inline.py]
[Размер: 0 байт]
[Дата изменения: 2026-01-28 10:03:18.086374]


-----

[Файл: c:\Users\Tixon11\obsidian\NewObsidian\Интеллект\Технический\Programming\aiogram\tg_bot_TaskEnforcer\app\myapi.py]
[Размер: 2085 байт]
[Дата изменения: 2026-01-31 20:14:04.741632]

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List
import app.database as db

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# ================= MODELS =================

class UserRegistration(BaseModel):
    tg_id: int
    name: str


class TaskCreate(BaseModel):
    user_id: int
    title: str


class TaskResponse(BaseModel):
    id: int
    title: str
    is_completed: bool


class HabitCreate(BaseModel):
    user_id: int
    title: str


class HabitResponse(BaseModel):
    id: int
    title: str
    is_completed_today: bool


# ================= USERS =================

@app.post("/api/register")
async def register_user(user: UserRegistration):
    try:
        db.add_user(user.tg_id, user.name)
        return {"status": "ok"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# ================= TASKS =================

@app.post("/api/tasks/add")
async def api_add_task(task: TaskCreate):
    db.add_task(task.user_id, task.title)
    return {"status": "ok"}


@app.get("/api/tasks/{user_id}", response_model=List[TaskResponse])
async def api_get_tasks(user_id: int):
    return db.get_user_tasks(user_id)


@app.post("/api/tasks/toggle/{task_id}")
async def api_toggle_task(task_id: int):
    db.toggle_task_status(task_id)
    return {"status": "ok"}


# ================= HABITS =================

@app.post("/api/habits/add")
async def api_add_habit(habit: HabitCreate):
    db.add_habit(habit.user_id, habit.title)
    return {"status": "ok"}


@app.get("/api/habits/{user_id}", response_model=List[HabitResponse])
async def api_get_habits(user_id: int):
    return db.get_user_habits(user_id)


@app.post("/api/habits/toggle/{habit_id}")
async def api_toggle_habit(habit_id: int):
    db.toggle_habit_today(habit_id)
    return {"status": "ok"}

-----

